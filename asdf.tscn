[gd_scene load_steps=138 format=2]

[ext_resource path="res://Scripts/Behavior.gd" type="Script" id=1]
[ext_resource path="res://Animations/Human/Action/Death/Death_Backward.tres" type="Animation" id=2]
[ext_resource path="res://Animations/Human/Action/Death/Death_Forward.tres" type="Animation" id=3]
[ext_resource path="res://Animations/Human/Action/Death/Death_Headshot.tres" type="Animation" id=4]
[ext_resource path="res://Animations/Human/Action/Death/Death_Minimum.tres" type="Animation" id=5]
[ext_resource path="res://Animations/Human/Action/Death/Death_Stomach.tres" type="Animation" id=6]
[ext_resource path="res://Animations/DefaultAnim.tres" type="Animation" id=7]
[ext_resource path="res://Animations/Human/ReloadBeretta.tres" type="Animation" id=8]
[ext_resource path="res://Animations/Human/Action/ShootBeretta.tres" type="Animation" id=9]
[ext_resource path="res://Animations/Human/Action/ShootBerettaIdle.tres" type="Animation" id=10]
[ext_resource path="res://Animations/Human/Action/ShootBerettaIdle_Down.tres" type="Animation" id=11]
[ext_resource path="res://Animations/Human/Action/ShootBerettaIdle_Up.tres" type="Animation" id=12]
[ext_resource path="res://Animations/Human/Action/ShootBeretta_Down.tres" type="Animation" id=13]
[ext_resource path="res://Animations/Human/Action/ShootBeretta_Up.tres" type="Animation" id=14]
[ext_resource path="res://Animations/Human/Action/Death/death_knees.tres" type="Animation" id=15]

[sub_resource type="GDScript" id=1]
script/source = "tool
extends AnimationNodeStateMachine

const camera_rig_track_path = '../../Perspective'

export(String) var statemachine
export var chain = false

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var children = get_children()
var animation_nodes = []
var statemachine_nodes = []
var animation_player

signal state_starting
signal travel_starting


func _on_state_starting(new_name):
	
	if node_name == new_name:
#		if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#			prints('meep ',new_name)
		
		advance = chain


func _filter_anim_events(is_action, filter_all=false):
	
	var playback = owner.get(parameters + 'playback')
	
	if not playback.get_current_node():
		return
	
	var current_node = get_node(playback.get_current_node())
	

	for animation_node in animation_nodes:

		var is_playing = get_node(animation_node) == current_node
		
		if not is_playing or filter_all:
			children[animation_node].call_methods = false  
		else:
			children[animation_node].call_methods = true
	
	
	for statemachine_node in statemachine_nodes:

		var is_playing = get_node(statemachine_node) == current_node
		
		if is_playing:
			children[statemachine_node]._filter_anim_events(is_action, filter_all)
		else:
			children[statemachine_node]._filter_anim_events(is_action, true)


func _unfilter_anim_events():
	
	for animation_node in animation_nodes:
		
		children[animation_node].call_methods = true


	for statemachine_node in statemachine_nodes:
		
		children[statemachine_node]._unfilter_anim_events()


func _travel(_name):
	
#	if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#		prints(OS.get_system_time_msecs(), _name)
#
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
	playback.travel(_name)
	
	if not playback.is_playing():
		prints('Not playing', owner.owner.name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _start(_name):
	
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
#	prints('starting', owner.owner.name, _name, owner.active)
	
	playback.start(_name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _editor_ready(_owner, _parent, _parameters, _name):
	
	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_editor_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._editor_ready(_owner, self, _parameters + child_name + '/', child_name)
			else:
				child._editor_ready(_owner, self, _parameters, child_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _node_name
	animation_player = owner.get_node_or_null('AnimationPlayer')
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')


	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._ready(owner, self, parameters + child_name + '/', child_name)
			else:
				child._ready(owner, self, parameters, child_name)
		
		
		if child is AnimationNodeAnimation:

			animation_nodes.append(child_name)

		elif child is AnimationNodeStateMachine or \\
			child is AnimationNodeBlendTree or \\
			child is AnimationNodeBlendSpace1D or \\
			child is AnimationNodeBlendSpace2D:
			
			if not child.has_method('_filter_anim_events'):
				continue
			
			statemachine_nodes.append(child_name)
	
	
	var transition_count = get_transition_count()
	var transitions = []
	var anim_names = []

	for idx in range(get_transition_count()):
		
		var from_name = get_transition_from(0)
		var to_name = get_transition_to(0)
		
		add_transition(from_name, to_name, get_transition(0).duplicate(true))
		remove_transition_by_index(0)


	for idx in range(get_transition_count()):

		var transition = get_transition(idx)
		var from_name = get_transition_from(idx)
		var to_name = get_transition_to(idx)
		var from = get_node(from_name)
		var to = get_node(to_name)

		if from.has_method('_ready'):
			from.connections.append(transition)

		if transition.has_method('_ready'):
			transition._ready(owner, self, parameters, from, to)
		
		add_transition(from_name, to_name, transition)


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
	
#	if statemachine == 'merrp':# and owner.owner.name == 'Infiltrator':
#		prints(owner.get(parameters + 'playback').get_current_play_pos())
"
__meta__ = {

}

[sub_resource type="GDScript" id=2]
script/source = "extends 'res://Scripts/AnimationTree.StateMachine.gd'

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	._on_state_starting(new_name)
	
	if node_name == new_name:
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="GDScript" id=3]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=4]
animation = "DefaultAnim"
script = SubResource( 3 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=5]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=6]
animation = "DefaultAnim"
scale = 1.5
script = SubResource( 5 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=7]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=8]
animation = "DefaultAnim"
scale = 0.5
script = SubResource( 7 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=9]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=10]
animation = "DefaultAnim"
script = SubResource( 9 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="GDScript" id=11]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=12]
animation = "DefaultAnim"
script = SubResource( 11 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="GDScript" id=13]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_value

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'Equals', 'Not Equals', 'Greater Than', 'Less Than') var assertion = 'Equals'
export(String) var target
export(String) var method
export(Array) var args
export(float) var value
export(float) var wait_for_frame

var target_node


func _evaluate(_value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:
		
		'Equals': return value == _value
		'Not Equals': return value != _value
		'Greater Than': return value < _value
		'Less Than': return value > _value


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	disabled = not _evaluate(owner.owner.get_node(target).callv(method, _args))


func _on_state_starting(new_name):
	
	var from_name = parent.get_node_name(from)
	
	if from_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	var target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	#yield(owner.get_tree(), 'idle_frame')
	
	owner.connect('on_process', self, '_process')


func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=14]
switch_mode = 2
auto_advance = true
disabled = true
script = SubResource( 13 )
__meta__ = {

}
transition_value = ""
update_mode = "state_starting"
assertion = "Greater Than"
target = "ClimbingSkill"
method = "_get_climb_height_mult"
args = [  ]
value = 0.7
wait_for_frame = 0.0

[sub_resource type="AnimationNodeStateMachineTransition" id=15]
switch_mode = 2
auto_advance = true
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=16]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=17]
switch_mode = 2
auto_advance = true
__meta__ = {

}

[sub_resource type="GDScript" id=18]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_value

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'Equals', 'Not Equals', 'Greater Than', 'Less Than') var assertion = 'Equals'
export(String) var target
export(String) var method
export(Array) var args
export(float) var value
export(float) var wait_for_frame

var target_node


func _evaluate(_value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:
		
		'Equals': return value == _value
		'Not Equals': return value != _value
		'Greater Than': return value < _value
		'Less Than': return value > _value


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	disabled = not _evaluate(owner.owner.get_node(target).callv(method, _args))


func _on_state_starting(new_name):
	
	var from_name = parent.get_node_name(from)
	
	if from_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	var target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	#yield(owner.get_tree(), 'idle_frame')
	
	owner.connect('on_process', self, '_process')


func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=19]
switch_mode = 2
auto_advance = true
disabled = true
script = SubResource( 18 )
__meta__ = {

}
transition_value = ""
update_mode = "state_starting"
assertion = "Less Than"
target = "ClimbingSkill"
method = "_get_climb_height_mult"
args = [  ]
value = 0.2
wait_for_frame = 0.0

[sub_resource type="AnimationNodeStateMachineTransition" id=20]
switch_mode = 2
auto_advance = true
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=21]
states/ClimbHigh/node = SubResource( 4 )
states/ClimbHigh/position = Vector2( 574, 47 )
states/ClimbLow/node = SubResource( 6 )
states/ClimbLow/position = Vector2( 574, 233 )
states/ClimbMedium/node = SubResource( 8 )
states/ClimbMedium/position = Vector2( 574, 141 )
states/End/node = SubResource( 10 )
states/End/position = Vector2( 907, 141 )
states/Start/node = SubResource( 12 )
states/Start/position = Vector2( 226, 141 )
transitions = [ "Start", "ClimbHigh", SubResource( 14 ), "ClimbHigh", "End", SubResource( 15 ), "Start", "ClimbMedium", SubResource( 16 ), "ClimbMedium", "End", SubResource( 17 ), "Start", "ClimbLow", SubResource( 19 ), "ClimbLow", "End", SubResource( 20 ), "Start", "ClimbHigh", SubResource( 14 ), "ClimbHigh", "End", SubResource( 15 ), "Start", "ClimbMedium", SubResource( 16 ), "ClimbMedium", "End", SubResource( 17 ), "Start", "ClimbLow", SubResource( 19 ), "ClimbLow", "End", SubResource( 20 ) ]
start_node = "Start"
end_node = "End"
script = SubResource( 2 )
__meta__ = {

}
statemachine = ""
chain = false
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = true
lock_speed = true
lock_direction = true
lock_rotation = true
lock_movement = true
camera_mode = "HalfYaw"

[sub_resource type="GDScript" id=22]
script/source = "extends \"res://Scripts/AnimationTree.Animation.gd\"

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=23]
animation = "Climb.Exit"
script = SubResource( 22 )
__meta__ = {

}
chain = true
schema = ""
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=24]
script/source = "extends \"res://Scripts/AnimationTree.Animation.gd\"

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=25]
animation = "Death_Backward"
clip_start = 0.05
script = SubResource( 24 )
__meta__ = {

}
chain = false
schema = "Die"
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = false
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=26]
script/source = "extends \"res://Scripts/AnimationTree.Animation.gd\"

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=27]
animation = "FindClimbTarget"
script = SubResource( 26 )
__meta__ = {

}
chain = true
schema = ""
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=28]
script/source = "tool
extends AnimationNodeStateMachine

const camera_rig_track_path = '../../Perspective'

export(String) var statemachine
export var chain = false

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var children = get_children()
var animation_nodes = []
var statemachine_nodes = []
var animation_player

signal state_starting
signal travel_starting


func _on_state_starting(new_name):
	
	if node_name == new_name:
#		if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#			prints('meep ',new_name)
		
		advance = chain


func _filter_anim_events(is_action, filter_all=false):
	
	var playback = owner.get(parameters + 'playback')
	
	if not playback.get_current_node():
		return
	
	var current_node = get_node(playback.get_current_node())
	

	for animation_node in animation_nodes:

		var is_playing = get_node(animation_node) == current_node
		
		if not is_playing or filter_all:
			children[animation_node].call_methods = false  
		else:
			children[animation_node].call_methods = true
	
	
	for statemachine_node in statemachine_nodes:

		var is_playing = get_node(statemachine_node) == current_node
		
		if is_playing:
			children[statemachine_node]._filter_anim_events(is_action, filter_all)
		else:
			children[statemachine_node]._filter_anim_events(is_action, true)


func _unfilter_anim_events():
	
	for animation_node in animation_nodes:
		
		children[animation_node].call_methods = true


	for statemachine_node in statemachine_nodes:
		
		children[statemachine_node]._unfilter_anim_events()


func _travel(_name):
	
#	if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#		prints(OS.get_system_time_msecs(), _name)
#
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
	playback.travel(_name)
	
	if not playback.is_playing():
		prints('Not playing', owner.owner.name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _start(_name):
	
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
#	prints('starting', owner.owner.name, _name, owner.active)
	
	playback.start(_name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _editor_ready(_owner, _parent, _parameters, _name):
	
	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_editor_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._editor_ready(_owner, self, _parameters + child_name + '/', child_name)
			else:
				child._editor_ready(_owner, self, _parameters, child_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _node_name
	animation_player = owner.get_node_or_null('AnimationPlayer')
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')


	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._ready(owner, self, parameters + child_name + '/', child_name)
			else:
				child._ready(owner, self, parameters, child_name)
		
		
		if child is AnimationNodeAnimation:

			animation_nodes.append(child_name)

		elif child is AnimationNodeStateMachine or \\
			child is AnimationNodeBlendTree or \\
			child is AnimationNodeBlendSpace1D or \\
			child is AnimationNodeBlendSpace2D:
			
			if not child.has_method('_filter_anim_events'):
				continue
			
			statemachine_nodes.append(child_name)
	
	
	var transition_count = get_transition_count()
	var transitions = []
	var anim_names = []

	for idx in range(get_transition_count()):
		
		var from_name = get_transition_from(0)
		var to_name = get_transition_to(0)
		
		add_transition(from_name, to_name, get_transition(0).duplicate(true))
		remove_transition_by_index(0)


	for idx in range(get_transition_count()):

		var transition = get_transition(idx)
		var from_name = get_transition_from(idx)
		var to_name = get_transition_to(idx)
		var from = get_node(from_name)
		var to = get_node(to_name)

		if from.has_method('_ready'):
			from.connections.append(transition)

		if transition.has_method('_ready'):
			transition._ready(owner, self, parameters, from, to)
		
		add_transition(from_name, to_name, transition)


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
	
#	if statemachine == 'merrp':# and owner.owner.name == 'Infiltrator':
#		prints(owner.get(parameters + 'playback').get_current_play_pos())
"
__meta__ = {

}

[sub_resource type="GDScript" id=29]
script/source = "extends AnimationNodeBlend3

export(String) var blend3
export var chain = false
export(String, MULTILINE) var expression
export(Dictionary) var arguments

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var exec_list = []

signal state_starting


func _evaluate():
	
	var result
	
	for exec in exec_list:
		
		result = exec.execute(arguments.values(), owner)
		
		if result == null:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, node_name, exec.get_error_text())
			
			return 0
	
	return result


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	owner.set(parameters + node_name + '/blend_amount', _evaluate())"
__meta__ = {

}

[sub_resource type="AnimationNodeBlend3" id=30]
sync = true
script = SubResource( 29 )
__meta__ = {

}
blend3 = ""
chain = false
expression = "get_node(CAMERA).rotation_degrees.x / 90"
arguments = {
"CAMERA": "../CameraRig/Camera"
}

[sub_resource type="AnimationNodeAnimation" id=31]
animation = "ShootBerettaIdle"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=32]
animation = "ShootBerettaIdle_Down"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=33]
animation = "ShootBerettaIdle_Up"
__meta__ = {

}

[sub_resource type="GDScript" id=34]
script/source = "extends \"res://Scripts/AnimationTree.BlendTree.gd\"

export(String, MULTILINE) var expression
export(Dictionary) var arguments
var exec_list = []

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var playing = false
var stance
var perspective
var anim_layer_movement


func _evaluate():
	
	for exec in exec_list:
		
		var result = exec.execute(arguments.values(), owner)
		
		if not result:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, exec.get_error_text())
			
			return false
	
	return true


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		playing = true
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.cache_poses = cache_pose
	
	else:
		
		playing = false
	
	._on_state_starting(new_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	._ready(_owner, _parent, _parameters, _node_name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	if parent and owner.get(parent.parameters + 'playback'):
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if playback.is_playing() and playing:
		
			if anim_layer_movement:
				
				if _evaluate():
					anim_layer_movement.blend_mode = Meta.Blend.LAYERED
				else:
					anim_layer_movement.blend_mode = Meta.Blend.ACTION
	
	else:
		
		playing = false
	
	._process(delta)
"
__meta__ = {

}

[sub_resource type="AnimationNodeBlendTree" id=35]
graph_offset = Vector2( -384.937, 71.975 )
nodes/Blend3/node = SubResource( 30 )
nodes/Blend3/position = Vector2( 120, 100 )
nodes/Default/node = SubResource( 31 )
nodes/Default/position = Vector2( -160, 140 )
nodes/Down/node = SubResource( 32 )
nodes/Down/position = Vector2( -160, 20 )
nodes/Up/node = SubResource( 33 )
nodes/Up/position = Vector2( -160, 260 )
nodes/output/position = Vector2( 460, 160 )
node_connections = [ "output", 0, "Blend3", "Blend3", 0, "Down", "Blend3", 1, "Default", "Blend3", 2, "Up" ]
script = SubResource( 34 )
__meta__ = {

}
chain = false
schema = "ShootIdle"
expression = "get_node(MOVEMENT)._get_speed() > 0.1 or get_node(STANCE).stance > 0"
arguments = {
"MOVEMENT": "../Movement",
"STANCE": "../Stance"
}
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=36]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=37]
animation = "DefaultAnim"
script = SubResource( 36 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="AnimationNodeStateMachineTransition" id=38]
auto_advance = true
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=39]
states/ShootOneHand/node = SubResource( 35 )
states/ShootOneHand/position = Vector2( 648, 95 )
states/Start/node = SubResource( 37 )
states/Start/position = Vector2( 360, 95 )
transitions = [ "Start", "ShootOneHand", SubResource( 38 ), "Start", "ShootOneHand", SubResource( 38 ) ]
start_node = "Start"
script = SubResource( 28 )
__meta__ = {

}
statemachine = "rewq"
chain = false

[sub_resource type="GDScript" id=40]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=41]
script = SubResource( 40 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=42]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=43]
animation = "DefaultAnim"
script = SubResource( 42 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=44]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=45]
animation = "DefaultAnim"
script = SubResource( 44 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=46]
script/source = "tool
extends AnimationNodeStateMachine

const camera_rig_track_path = '../../Perspective'

export(String) var statemachine
export var chain = false

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var children = get_children()
var animation_nodes = []
var statemachine_nodes = []
var animation_player

signal state_starting
signal travel_starting


func _on_state_starting(new_name):
	
	if node_name == new_name:
#		if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#			prints('meep ',new_name)
		
		advance = chain


func _filter_anim_events(is_action, filter_all=false):
	
	var playback = owner.get(parameters + 'playback')
	
	if not playback.get_current_node():
		return
	
	var current_node = get_node(playback.get_current_node())
	

	for animation_node in animation_nodes:

		var is_playing = get_node(animation_node) == current_node
		
		if not is_playing or filter_all:
			children[animation_node].call_methods = false  
		else:
			children[animation_node].call_methods = true
	
	
	for statemachine_node in statemachine_nodes:

		var is_playing = get_node(statemachine_node) == current_node
		
		if is_playing:
			children[statemachine_node]._filter_anim_events(is_action, filter_all)
		else:
			children[statemachine_node]._filter_anim_events(is_action, true)


func _unfilter_anim_events():
	
	for animation_node in animation_nodes:
		
		children[animation_node].call_methods = true


	for statemachine_node in statemachine_nodes:
		
		children[statemachine_node]._unfilter_anim_events()


func _travel(_name):
	
#	if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#		prints(OS.get_system_time_msecs(), _name)
#
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
	playback.travel(_name)
	
	if not playback.is_playing():
		prints('Not playing', owner.owner.name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _start(_name):
	
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
#	prints('starting', owner.owner.name, _name, owner.active)
	
	playback.start(_name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _editor_ready(_owner, _parent, _parameters, _name):
	
	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_editor_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._editor_ready(_owner, self, _parameters + child_name + '/', child_name)
			else:
				child._editor_ready(_owner, self, _parameters, child_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _node_name
	animation_player = owner.get_node_or_null('AnimationPlayer')
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')


	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._ready(owner, self, parameters + child_name + '/', child_name)
			else:
				child._ready(owner, self, parameters, child_name)
		
		
		if child is AnimationNodeAnimation:

			animation_nodes.append(child_name)

		elif child is AnimationNodeStateMachine or \\
			child is AnimationNodeBlendTree or \\
			child is AnimationNodeBlendSpace1D or \\
			child is AnimationNodeBlendSpace2D:
			
			if not child.has_method('_filter_anim_events'):
				continue
			
			statemachine_nodes.append(child_name)
	
	
	var transition_count = get_transition_count()
	var transitions = []
	var anim_names = []

	for idx in range(get_transition_count()):
		
		var from_name = get_transition_from(0)
		var to_name = get_transition_to(0)
		
		add_transition(from_name, to_name, get_transition(0).duplicate(true))
		remove_transition_by_index(0)


	for idx in range(get_transition_count()):

		var transition = get_transition(idx)
		var from_name = get_transition_from(idx)
		var to_name = get_transition_to(idx)
		var from = get_node(from_name)
		var to = get_node(to_name)

		if from.has_method('_ready'):
			from.connections.append(transition)

		if transition.has_method('_ready'):
			transition._ready(owner, self, parameters, from, to)
		
		add_transition(from_name, to_name, transition)


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
	
#	if statemachine == 'merrp':# and owner.owner.name == 'Infiltrator':
#		prints(owner.get(parameters + 'playback').get_current_play_pos())
"
__meta__ = {

}

[sub_resource type="GDScript" id=47]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=48]
animation = "DefaultAnim"
script = SubResource( 47 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="GDScript" id=49]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=50]
animation = "JumpLong"
script = SubResource( 49 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=51]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_boolean

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'True', 'False', 'Null', 'NotNull') var assertion = 'True'
export(String) var target
export(String) var method
export(Array) var args
export(float) var wait_for_frame

var target_node


func _evaluate(value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:

		'True': return value
		'False': return not value
		'Null': return value == null
		'NotNull': return value != null


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	
	disabled = not _evaluate(target_node.callv(method, _args))


func _on_state_starting(new_name):
	
#	if from.get('node_name') == null:
#		return
	
	if from.node_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
#	if owner.name == 'Behavior' and target == 'RightHandContainer':
#		prints(_owner.owner.name, self)



func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=52]
auto_advance = true
disabled = true
script = SubResource( 51 )
__meta__ = {

}
transition_boolean = ""
update_mode = "process"
assertion = "True"
target = "."
method = "is_on_floor"
args = [  ]
wait_for_frame = 0.5

[sub_resource type="AnimationNodeStateMachineTransition" id=53]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=54]
states/End/node = SubResource( 48 )
states/End/position = Vector2( 822, 99 )
states/JumpLong/node = SubResource( 50 )
states/JumpLong/position = Vector2( 606, 99 )
transitions = [ "JumpLong", "End", SubResource( 52 ), "JumpLong", "End", SubResource( 53 ), "JumpLong", "End", SubResource( 52 ), "JumpLong", "End", SubResource( 53 ) ]
start_node = "JumpLong"
end_node = "End"
script = SubResource( 46 )
__meta__ = {

}
statemachine = ""
chain = false

[sub_resource type="GDScript" id=55]
script/source = "tool
extends AnimationNodeStateMachine

const camera_rig_track_path = '../../Perspective'

export(String) var statemachine
export var chain = false

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var children = get_children()
var animation_nodes = []
var statemachine_nodes = []
var animation_player

signal state_starting
signal travel_starting


func _on_state_starting(new_name):
	
	if node_name == new_name:
#		if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#			prints('meep ',new_name)
		
		advance = chain


func _filter_anim_events(is_action, filter_all=false):
	
	var playback = owner.get(parameters + 'playback')
	
	if not playback.get_current_node():
		return
	
	var current_node = get_node(playback.get_current_node())
	

	for animation_node in animation_nodes:

		var is_playing = get_node(animation_node) == current_node
		
		if not is_playing or filter_all:
			children[animation_node].call_methods = false  
		else:
			children[animation_node].call_methods = true
	
	
	for statemachine_node in statemachine_nodes:

		var is_playing = get_node(statemachine_node) == current_node
		
		if is_playing:
			children[statemachine_node]._filter_anim_events(is_action, filter_all)
		else:
			children[statemachine_node]._filter_anim_events(is_action, true)


func _unfilter_anim_events():
	
	for animation_node in animation_nodes:
		
		children[animation_node].call_methods = true


	for statemachine_node in statemachine_nodes:
		
		children[statemachine_node]._unfilter_anim_events()


func _travel(_name):
	
#	if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#		prints(OS.get_system_time_msecs(), _name)
#
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
	playback.travel(_name)
	
	if not playback.is_playing():
		prints('Not playing', owner.owner.name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _start(_name):
	
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
#	prints('starting', owner.owner.name, _name, owner.active)
	
	playback.start(_name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _editor_ready(_owner, _parent, _parameters, _name):
	
	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_editor_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._editor_ready(_owner, self, _parameters + child_name + '/', child_name)
			else:
				child._editor_ready(_owner, self, _parameters, child_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _node_name
	animation_player = owner.get_node_or_null('AnimationPlayer')
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')


	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._ready(owner, self, parameters + child_name + '/', child_name)
			else:
				child._ready(owner, self, parameters, child_name)
		
		
		if child is AnimationNodeAnimation:

			animation_nodes.append(child_name)

		elif child is AnimationNodeStateMachine or \\
			child is AnimationNodeBlendTree or \\
			child is AnimationNodeBlendSpace1D or \\
			child is AnimationNodeBlendSpace2D:
			
			if not child.has_method('_filter_anim_events'):
				continue
			
			statemachine_nodes.append(child_name)
	
	
	var transition_count = get_transition_count()
	var transitions = []
	var anim_names = []

	for idx in range(get_transition_count()):
		
		var from_name = get_transition_from(0)
		var to_name = get_transition_to(0)
		
		add_transition(from_name, to_name, get_transition(0).duplicate(true))
		remove_transition_by_index(0)


	for idx in range(get_transition_count()):

		var transition = get_transition(idx)
		var from_name = get_transition_from(idx)
		var to_name = get_transition_to(idx)
		var from = get_node(from_name)
		var to = get_node(to_name)

		if from.has_method('_ready'):
			from.connections.append(transition)

		if transition.has_method('_ready'):
			transition._ready(owner, self, parameters, from, to)
		
		add_transition(from_name, to_name, transition)


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
	
#	if statemachine == 'merrp':# and owner.owner.name == 'Infiltrator':
#		prints(owner.get(parameters + 'playback').get_current_play_pos())
"
__meta__ = {

}

[sub_resource type="GDScript" id=56]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=57]
animation = "DefaultAnim"
script = SubResource( 56 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="GDScript" id=58]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=59]
animation = "JumpUp"
script = SubResource( 58 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=60]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_boolean

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'True', 'False', 'Null', 'NotNull') var assertion = 'True'
export(String) var target
export(String) var method
export(Array) var args
export(float) var wait_for_frame

var target_node


func _evaluate(value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:

		'True': return value
		'False': return not value
		'Null': return value == null
		'NotNull': return value != null


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	
	disabled = not _evaluate(target_node.callv(method, _args))


func _on_state_starting(new_name):
	
#	if from.get('node_name') == null:
#		return
	
	if from.node_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
#	if owner.name == 'Behavior' and target == 'RightHandContainer':
#		prints(_owner.owner.name, self)



func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=61]
auto_advance = true
disabled = true
script = SubResource( 60 )
__meta__ = {

}
transition_boolean = ""
update_mode = "process"
assertion = "True"
target = "."
method = "is_on_floor"
args = [  ]
wait_for_frame = 0.5

[sub_resource type="AnimationNodeStateMachineTransition" id=62]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=63]
states/End/node = SubResource( 57 )
states/End/position = Vector2( 748, 92 )
states/JumpUp/node = SubResource( 59 )
states/JumpUp/position = Vector2( 536, 92 )
transitions = [ "JumpUp", "End", SubResource( 61 ), "JumpUp", "End", SubResource( 62 ), "JumpUp", "End", SubResource( 61 ), "JumpUp", "End", SubResource( 62 ) ]
start_node = "JumpUp"
end_node = "End"
script = SubResource( 55 )
__meta__ = {

}
statemachine = ""
chain = false

[sub_resource type="GDScript" id=64]
script/source = "tool
extends AnimationNodeStateMachine

const camera_rig_track_path = '../../Perspective'

export(String) var statemachine
export var chain = false

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var children = get_children()
var animation_nodes = []
var statemachine_nodes = []
var animation_player

signal state_starting
signal travel_starting


func _on_state_starting(new_name):
	
	if node_name == new_name:
#		if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#			prints('meep ',new_name)
		
		advance = chain


func _filter_anim_events(is_action, filter_all=false):
	
	var playback = owner.get(parameters + 'playback')
	
	if not playback.get_current_node():
		return
	
	var current_node = get_node(playback.get_current_node())
	

	for animation_node in animation_nodes:

		var is_playing = get_node(animation_node) == current_node
		
		if not is_playing or filter_all:
			children[animation_node].call_methods = false  
		else:
			children[animation_node].call_methods = true
	
	
	for statemachine_node in statemachine_nodes:

		var is_playing = get_node(statemachine_node) == current_node
		
		if is_playing:
			children[statemachine_node]._filter_anim_events(is_action, filter_all)
		else:
			children[statemachine_node]._filter_anim_events(is_action, true)


func _unfilter_anim_events():
	
	for animation_node in animation_nodes:
		
		children[animation_node].call_methods = true


	for statemachine_node in statemachine_nodes:
		
		children[statemachine_node]._unfilter_anim_events()


func _travel(_name):
	
#	if owner.name == 'Behavior' and owner.owner.name == 'Infiltrator':
#		prints(OS.get_system_time_msecs(), _name)
#
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
	playback.travel(_name)
	
	if not playback.is_playing():
		prints('Not playing', owner.owner.name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _start(_name):
	
	var playback = owner.get(parameters + 'playback')
	var current = playback.get_current_node()
	
	if not has_node(_name):
		return
	
	
	owner.emit_signal('travel_starting', _name, get_node(_name))
	
#	prints('starting', owner.owner.name, _name, owner.active)
	
	playback.start(_name)
	
#	owner.advance(0.01)
#	owner.emit_signal('on_process', 0)


func _editor_ready(_owner, _parent, _parameters, _name):
	
	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_editor_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._editor_ready(_owner, self, _parameters + child_name + '/', child_name)
			else:
				child._editor_ready(_owner, self, _parameters, child_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _node_name
	animation_player = owner.get_node_or_null('AnimationPlayer')
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')


	var children = get_children()

	for child_name in children:
		
		var child = children[child_name]
		
		if child.has_method('_ready'):

			if child is AnimationNodeStateMachine or \\
				child is AnimationNodeBlendTree or \\
				child is AnimationNodeBlendSpace1D or \\
				child is AnimationNodeBlendSpace2D:
				child._ready(owner, self, parameters + child_name + '/', child_name)
			else:
				child._ready(owner, self, parameters, child_name)
		
		
		if child is AnimationNodeAnimation:

			animation_nodes.append(child_name)

		elif child is AnimationNodeStateMachine or \\
			child is AnimationNodeBlendTree or \\
			child is AnimationNodeBlendSpace1D or \\
			child is AnimationNodeBlendSpace2D:
			
			if not child.has_method('_filter_anim_events'):
				continue
			
			statemachine_nodes.append(child_name)
	
	
	var transition_count = get_transition_count()
	var transitions = []
	var anim_names = []

	for idx in range(get_transition_count()):
		
		var from_name = get_transition_from(0)
		var to_name = get_transition_to(0)
		
		add_transition(from_name, to_name, get_transition(0).duplicate(true))
		remove_transition_by_index(0)


	for idx in range(get_transition_count()):

		var transition = get_transition(idx)
		var from_name = get_transition_from(idx)
		var to_name = get_transition_to(idx)
		var from = get_node(from_name)
		var to = get_node(to_name)

		if from.has_method('_ready'):
			from.connections.append(transition)

		if transition.has_method('_ready'):
			transition._ready(owner, self, parameters, from, to)
		
		add_transition(from_name, to_name, transition)


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
	
#	if statemachine == 'merrp':# and owner.owner.name == 'Infiltrator':
#		prints(owner.get(parameters + 'playback').get_current_play_pos())
"
__meta__ = {

}

[sub_resource type="GDScript" id=65]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=66]
animation = "DefaultAnim"
script = SubResource( 65 )
__meta__ = {

}
chain = true
schema = ""

[sub_resource type="GDScript" id=67]
script/source = "extends AnimationNodeAnimation

const schemas_dir = 'res://Scenes/Schemas/'
const schemas_extension = '.schema.tscn'

export var chain = false
export(String) var schema

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var default_scale
var animation_list = []
var attributes = {}

signal state_starting


func _load_animations():
	
	if not schema or schema == '':# or not owner.has_node('../Model'):
		return
	
	default_scale = scale
	
	
	var animation_player = owner.get_node('AnimationPlayer')
	var owner_tags = owner.owner.tags_dict.keys()#[]
	
#	if owner.owner._has_tag(owner.schema_type):
#		owner_tags = owner.owner._get_tag(owner.schema_type)
	
	var files = Meta._get_files_recursive(schemas_dir, schema, schemas_extension, owner_tags)
	
	var schema_animation_player = load(files[0]).instance()
	animation_list = Array(schema_animation_player.get_animation_list())
	
	if schema_animation_player.get('attributes'):
		attributes = parse_json(schema_animation_player.attributes)
	
	for animation_name in animation_list:
		
		var animation_res = schema_animation_player.get_animation(animation_name)
		animation_player.add_animation(animation_name, animation_res)
	
	
	animation = animation_list[0]
	
	if attributes.has(animation):
		scale = default_scale * attributes[animation].speed


func _randomize_animation():
	
	if len(animation_list) > 0:
		
		animation_list.shuffle()
		animation = animation_list[0]
		
		if attributes.has(animation):
			scale = default_scale * attributes[animation].speed


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		advance = chain
		
		emit_signal('state_starting', node_name, owner.data)
	
		_randomize_animation()


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	#print(node_name) if owner.name == 'PrimaryAction' else null
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	_load_animations()


func _process(delta):
	
	if advance:
		owner.advance(0.01)
	
	advance = false
"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=68]
animation = "JumpUp"
script = SubResource( 67 )
__meta__ = {

}
chain = false
schema = ""

[sub_resource type="GDScript" id=69]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_boolean

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'True', 'False', 'Null', 'NotNull') var assertion = 'True'
export(String) var target
export(String) var method
export(Array) var args
export(float) var wait_for_frame

var target_node


func _evaluate(value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:

		'True': return value
		'False': return not value
		'Null': return value == null
		'NotNull': return value != null


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	
	disabled = not _evaluate(target_node.callv(method, _args))


func _on_state_starting(new_name):
	
#	if from.get('node_name') == null:
#		return
	
	if from.node_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
#	if owner.name == 'Behavior' and target == 'RightHandContainer':
#		prints(_owner.owner.name, self)



func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=70]
auto_advance = true
disabled = true
script = SubResource( 69 )
__meta__ = {

}
transition_boolean = ""
update_mode = "process"
assertion = "True"
target = "."
method = "is_on_floor"
args = [  ]
wait_for_frame = 0.5

[sub_resource type="AnimationNodeStateMachineTransition" id=71]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=72]
states/End/node = SubResource( 66 )
states/End/position = Vector2( 778, 112 )
states/jumpForward/node = SubResource( 68 )
states/jumpForward/position = Vector2( 517, 112 )
transitions = [ "jumpForward", "End", SubResource( 70 ), "jumpForward", "End", SubResource( 71 ), "jumpForward", "End", SubResource( 70 ), "jumpForward", "End", SubResource( 71 ) ]
start_node = "jumpForward"
end_node = "End"
script = SubResource( 64 )
__meta__ = {

}
statemachine = ""
chain = false

[sub_resource type="GDScript" id=73]
script/source = "extends 'res://Scripts/AnimationTree.BlendSpace.gd'

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose
	
	._on_state_starting(new_name)


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeBlendSpace2D" id=74]
blend_point_0/node = SubResource( 41 )
blend_point_0/pos = Vector2( -0.2, 0 )
blend_point_1/node = SubResource( 43 )
blend_point_1/pos = Vector2( 0.2, 0 )
blend_point_2/node = SubResource( 45 )
blend_point_2/pos = Vector2( 0, -0.2 )
blend_point_3/node = SubResource( 54 )
blend_point_3/pos = Vector2( 0, 1 )
blend_point_4/node = SubResource( 63 )
blend_point_4/pos = Vector2( 0, 0 )
blend_point_5/node = SubResource( 72 )
blend_point_5/pos = Vector2( 0, 0.2 )
blend_mode = 1
script = SubResource( 73 )
__meta__ = {

}
blendspace = ""
chain = false
update_mode = "state_starting"
speed = 0.0
x_target = "Movement"
x_method = "_get_sidestep_speed"
x_args = [  ]
x_max_value = -2.75
x_min_value = 2.75
y_target = "Movement"
y_method = "_get_forward_speed"
y_args = [  ]
y_max_value = 2.75
y_min_value = -2.75
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = true
lock_speed = true
lock_direction = false
lock_rotation = true
lock_movement = true
camera_mode = "HalfYaw"

[sub_resource type="GDScript" id=75]
script/source = "extends \"res://Scripts/AnimationTree.Animation.gd\"

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=76]
animation = "ReloadBeretta"
clip_start = 0.05
script = SubResource( 75 )
__meta__ = {

}
chain = false
schema = "Reload"
priority = 0
type = 0
blend = 2
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=77]
script/source = "extends AnimationNodeBlend3

export(String) var blend3
export var chain = false
export(String, MULTILINE) var expression
export(Dictionary) var arguments

var node_name
var owner
var parent
var parameters
var connections = []
var advance = false

var exec_list = []

signal state_starting


func _evaluate():
	
	var result
	
	for exec in exec_list:
		
		result = exec.execute(arguments.values(), owner)
		
		if result == null:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, node_name, exec.get_error_text())
			
			return 0
	
	return result


func _ready(_owner, _parent, _parameters, _name):
	
	owner = _owner
	parent = _parent
	parameters = _parameters
	node_name = _name
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('on_process', self, '_process')
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	owner.set(parameters + node_name + '/blend_amount', _evaluate())"
__meta__ = {

}

[sub_resource type="AnimationNodeBlend3" id=78]
sync = true
script = SubResource( 77 )
__meta__ = {

}
blend3 = ""
chain = false
expression = "get_node(CAMERA).rotation_degrees.x / 90"
arguments = {
"CAMERA": "../CameraRig/Camera"
}

[sub_resource type="AnimationNodeAnimation" id=79]
animation = "ShootBeretta"
clip_start = 0.05
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=80]
animation = "ShootBeretta_Down"
clip_start = 0.05
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=81]
animation = "ShootBeretta_Up"
clip_start = 0.05
__meta__ = {

}

[sub_resource type="GDScript" id=82]
script/source = "extends \"res://Scripts/AnimationTree.BlendTree.gd\"

export(String, MULTILINE) var expression
export(Dictionary) var arguments
var exec_list = []

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var playing = false
var stance
var perspective
var anim_layer_movement


func _evaluate():
	
	for exec in exec_list:
		
		var result = exec.execute(arguments.values(), owner)
		
		if not result:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, exec.get_error_text())
			
			return false
	
	return true


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		playing = true
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.cache_poses = cache_pose
	
	else:
		
		playing = false
	
	._on_state_starting(new_name)


func _ready(_owner, _parent, _parameters, _node_name):
	
	._ready(_owner, _parent, _parameters, _node_name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	if parent and owner.get(parent.parameters + 'playback'):
		
		var playback = owner.get(parent.parameters + 'playback')
		
		if playback.is_playing() and playing:
		
			if anim_layer_movement:
				
				if _evaluate():
					anim_layer_movement.blend_mode = Meta.Blend.LAYERED
				else:
					anim_layer_movement.blend_mode = Meta.Blend.ACTION
	
	else:
		
		playing = false
	
	._process(delta)
"
__meta__ = {

}

[sub_resource type="AnimationNodeBlendTree" id=83]
graph_offset = Vector2( -238.809, 4.21986 )
nodes/Blend3/node = SubResource( 78 )
nodes/Blend3/position = Vector2( 180, 100 )
nodes/Default/node = SubResource( 79 )
nodes/Default/position = Vector2( -160, 140 )
nodes/Down/node = SubResource( 80 )
nodes/Down/position = Vector2( -160, 20 )
nodes/Up/node = SubResource( 81 )
nodes/Up/position = Vector2( -160, 260 )
nodes/output/position = Vector2( 460, 160 )
node_connections = [ "output", 0, "Blend3", "Blend3", 0, "Down", "Blend3", 1, "Default", "Blend3", 2, "Up" ]
script = SubResource( 82 )
__meta__ = {

}
chain = false
schema = "Shoot"
expression = "get_node(MOVEMENT)._get_speed() > 0.1 or get_node(STANCE).stance > 0"
arguments = {
"MOVEMENT": "../Movement",
"STANCE": "../Stance"
}
priority = 0
type = 0
blend = 0
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="GDScript" id=84]
script/source = "extends \"res://Scripts/AnimationTree.Animation.gd\"

export(Meta.Priority) var priority
export(Meta.Visibility) var type
export(Meta.Blend) var blend
export var cache_pose = true
export var distance = 0.0
export var enable_abilities = true
export var lock_stance = false
export var lock_speed = false
export var lock_direction = false
export var lock_rotation = false
export var lock_movement = false
export var camera_mode = 'LockYaw'

var stance
var perspective
var anim_layer_movement


func _is_visible():
	
	return type != Meta.Visibility.INVISIBLE


func _on_state_starting(new_name):
	
	if node_name == new_name:
		
		var playback = owner.get(parameters + 'playback')
		
		if len(playback.get_travel_path()) == 0:
			
			owner.enable_abilities = enable_abilities
			
			if stance:
				stance.lock_stance = lock_stance
				stance.lock_speed = lock_speed
				stance.lock_direction = lock_direction
				stance.lock_rotation = lock_rotation
				stance.lock_movement = lock_movement
			
			if perspective:
				perspective._start_state(camera_mode)
			
			if anim_layer_movement:
				anim_layer_movement.blend_mode = blend
				anim_layer_movement.cache_poses = cache_pose


func _ready(_owner, _parent, _parameters, _name):
	
	._ready(_owner, _parent, _parameters, _name)
	
	stance = owner.owner.get_node_or_null('Stance')
	perspective = owner.owner.get_node_or_null('Perspective')
	anim_layer_movement = owner.owner.get_node_or_null('AnimLayerMovement')"
__meta__ = {

}

[sub_resource type="AnimationNodeAnimation" id=85]
animation = "DefaultAnim"
script = SubResource( 84 )
__meta__ = {

}
chain = false
schema = ""
priority = 0
type = 0
blend = 1
cache_pose = true
distance = 0.0
enable_abilities = true
lock_stance = false
lock_speed = false
lock_direction = false
lock_rotation = false
lock_movement = false
camera_mode = "LockYaw"

[sub_resource type="AnimationNodeAnimation" id=86]
animation = "DefaultAnim"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=87]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=88]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="GDScript" id=89]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_priority


func _on_state_starting(new_name):
	
	pass


func _on_travel_starting(new_node_name, new_node):
	
	if new_node.get('priority') == null:
		disabled = true
		return
	
	disabled = not new_node.priority > from.priority


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('travel_starting', self, '_on_travel_starting')
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=90]
auto_advance = true
disabled = true
script = SubResource( 89 )
__meta__ = {

}
transition_priority = ""

[sub_resource type="GDScript" id=91]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_boolean

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'True', 'False', 'Null', 'NotNull') var assertion = 'True'
export(String) var target
export(String) var method
export(Array) var args
export(float) var wait_for_frame

var target_node


func _evaluate(value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:

		'True': return value
		'False': return not value
		'Null': return value == null
		'NotNull': return value != null


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	
	disabled = not _evaluate(target_node.callv(method, _args))


func _on_state_starting(new_name):
	
#	if from.get('node_name') == null:
#		return
	
	if from.node_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
#	if owner.name == 'Behavior' and target == 'RightHandContainer':
#		prints(_owner.owner.name, self)



func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=92]
auto_advance = true
disabled = true
script = SubResource( 91 )
__meta__ = {

}
transition_boolean = ""
update_mode = "process"
assertion = "True"
target = "."
method = "is_on_floor"
args = [  ]
wait_for_frame = 0.5

[sub_resource type="AnimationNodeStateMachineTransition" id=93]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="GDScript" id=94]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_boolean

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, 'True', 'False', 'Null', 'NotNull') var assertion = 'True'
export(String) var target
export(String) var method
export(Array) var args
export(float) var wait_for_frame

var target_node


func _evaluate(value):
	
	var playback = owner.get(parameters + 'playback')
	
	var current_frame = 0 if not playback.is_playing() else playback.get_current_play_pos()
	
	if current_frame < wait_for_frame:
		return false
	
	match assertion:

		'True': return value
		'False': return not value
		'Null': return value == null
		'NotNull': return value != null


func _update():
	
	var _args = []
	
	for arg in args:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	
	disabled = not _evaluate(target_node.callv(method, _args))


func _on_state_starting(new_name):
	
#	if from.get('node_name') == null:
#		return
	
	if from.node_name == new_name and update_mode == 'state_starting':
		_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	target_node = owner.owner.get_node(target)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
#	if owner.name == 'Behavior' and target == 'RightHandContainer':
#		prints(_owner.owner.name, self)



func _process(delta):
	
	if update_mode == 'process':
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=95]
switch_mode = 2
auto_advance = true
disabled = true
script = SubResource( 94 )
__meta__ = {

}
transition_boolean = ""
update_mode = "process"
assertion = "True"
target = "ClimbingSkill"
method = "_has_targets"
args = [  ]
wait_for_frame = 0.0

[sub_resource type="GDScript" id=96]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_priority


func _on_state_starting(new_name):
	
	pass


func _on_travel_starting(new_node_name, new_node):
	
	if new_node.get('priority') == null:
		disabled = true
		return
	
	disabled = not new_node.priority > from.priority


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	owner.connect('travel_starting', self, '_on_travel_starting')
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=97]
auto_advance = true
disabled = true
script = SubResource( 96 )
__meta__ = {

}
transition_priority = ""

[sub_resource type="AnimationNodeStateMachineTransition" id=98]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=99]
switch_mode = 2
auto_advance = true
__meta__ = {

}

[sub_resource type="GDScript" id=100]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_expression

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, MULTILINE) var expression
export(Dictionary) var arguments
export(float) var delay

var exec_list = []
var timeout = false


func _evaluate():
	
	for exec in exec_list:
		
		var result = exec.execute(arguments.values(), owner)
#		if 'Anderson' in owner.owner.name:
#			print(owner.data.source._has_tag('Item'))
		
		if not result:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, exec_list.find(exec), exec.get_error_text())
			
			return false
	
	return true


func _update():
	
	if delay > 0 and not timeout:
		disabled = true
	
	var _args = []
	
	for arg in arguments:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	disabled = not _evaluate()


func _on_state_starting(new_name):
	
	var from_name = parent.get_node_name(from)
	
	if from_name == new_name:
		
		if delay > 0:
			owner.get_tree().create_timer(delay).connect('timeout', self, 'set', ['timeout', true])
		
		if update_mode == 'state_starting':
			_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
#	if owner.name == 'Behavior':
#		prints(owner.owner.name, owner.name, self)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	if update_mode == 'process':
		
#		if owner.owner.name == 'Infiltrator' and transition_expression in ['fdsa', 'asdf']:
#			prints(transition_expression, not disabled)
		
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=101]
auto_advance = true
disabled = true
script = SubResource( 100 )
__meta__ = {

}
transition_expression = ""
update_mode = "process"
expression = "get_node(RIGHTHAND)._has_item_with_tag(TAG)"
arguments = {
"RIGHTHAND": "../RightHandContainer",
"TAG": "Firearm"
}
delay = 0.0

[sub_resource type="AnimationNodeStateMachineTransition" id=102]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=103]
__meta__ = {

}

[sub_resource type="GDScript" id=104]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_expression

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, MULTILINE) var expression
export(Dictionary) var arguments
export(float) var delay

var exec_list = []
var timeout = false


func _evaluate():
	
	for exec in exec_list:
		
		var result = exec.execute(arguments.values(), owner)
#		if 'Anderson' in owner.owner.name:
#			print(owner.data.source._has_tag('Item'))
		
		if not result:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, exec_list.find(exec), exec.get_error_text())
			
			return false
	
	return true


func _update():
	
	if delay > 0 and not timeout:
		disabled = true
	
	var _args = []
	
	for arg in arguments:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	disabled = not _evaluate()


func _on_state_starting(new_name):
	
	var from_name = parent.get_node_name(from)
	
	if from_name == new_name:
		
		if delay > 0:
			owner.get_tree().create_timer(delay).connect('timeout', self, 'set', ['timeout', true])
		
		if update_mode == 'state_starting':
			_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
#	if owner.name == 'Behavior':
#		prints(owner.owner.name, owner.name, self)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	if update_mode == 'process':
		
#		if owner.owner.name == 'Infiltrator' and transition_expression in ['fdsa', 'asdf']:
#			prints(transition_expression, not disabled)
		
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=105]
auto_advance = true
disabled = true
script = SubResource( 104 )
__meta__ = {

}
transition_expression = ""
update_mode = "state_starting"
expression = "true if get_node(RIGHTHAND)._has_item_with_tag(FIREARM) else false"
arguments = {
"FIREARM": "Firearm",
"RIGHTHAND": "../RightHandContainer"
}
delay = 0.0

[sub_resource type="GDScript" id=106]
script/source = "extends 'res://Scripts/AnimationTree.Transition.gd'

export(String) var transition_expression

export(String, 'process', 'state_starting', 'travel_starting') var update_mode = 'process'

export(String, MULTILINE) var expression
export(Dictionary) var arguments
export(float) var delay

var exec_list = []
var timeout = false


func _evaluate():
	
	for exec in exec_list:
		
		var result = exec.execute(arguments.values(), owner)
#		if 'Anderson' in owner.owner.name:
#			print(owner.data.source._has_tag('Item'))
		
		if not result:
		
			if exec.has_execute_failed():
				
				prints(owner.owner.name, exec_list.find(exec), exec.get_error_text())
			
			return false
	
	return true


func _update():
	
	if delay > 0 and not timeout:
		disabled = true
	
	var _args = []
	
	for arg in arguments:
		
		if arg is String and arg.begins_with('$'):
			arg = owner.get_indexed(arg.replace('$', ''))
		
		_args.append(arg)
	
	disabled = not _evaluate()


func _on_state_starting(new_name):
	
	var from_name = parent.get_node_name(from)
	
	if from_name == new_name:
		
		if delay > 0:
			owner.get_tree().create_timer(delay).connect('timeout', self, 'set', ['timeout', true])
		
		if update_mode == 'state_starting':
			_update()


func _on_travel_starting(new_name):
	
	if update_mode == 'travel_starting':
		_update()


func _ready(_owner, _parent, _parameters, _from, _to):
	
	._ready(_owner, _parent, _parameters, _from, _to)
	
#	if owner.name == 'Behavior':
#		prints(owner.owner.name, owner.name, self)
	
	if parent != null and owner.get(parent.parameters + 'playback') != null:
		owner.get(parent.parameters + 'playback').connect('state_starting', self, '_on_state_starting')
	
	if parent != null and parent.has_user_signal('travel_starting'):
		parent.connect('travel_starting', self, '_on_travel_starting')
	
	owner.connect('on_process', self, '_process')
	
	
	for line in expression.split('\\n'):
		
		var exec = Expression.new()
		exec.parse(line, arguments.keys())
		exec_list.append(exec)


func _process(delta):
	
	if update_mode == 'process':
		
#		if owner.owner.name == 'Infiltrator' and transition_expression in ['fdsa', 'asdf']:
#			prints(transition_expression, not disabled)
		
		_update()
"
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=107]
switch_mode = 2
auto_advance = true
priority = 2
disabled = true
script = SubResource( 106 )
__meta__ = {

}
transition_expression = ""
update_mode = "process"
expression = "get_node(RIGHTHAND)._has_item_with_tag(TAG)"
arguments = {
"RIGHTHAND": "../RightHandContainer",
"TAG": "Firearm"
}
delay = 0.0

[sub_resource type="AnimationNodeStateMachineTransition" id=108]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=109]
switch_mode = 2
auto_advance = true
priority = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=110]
switch_mode = 2
auto_advance = true
priority = 3
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=111]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=112]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=113]
switch_mode = 2
auto_advance = true
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=114]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachineTransition" id=115]
switch_mode = 2
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachine" id=116]
states/Climb/node = SubResource( 21 )
states/Climb/position = Vector2( 0, 0 )
states/ClimbExit/node = SubResource( 23 )
states/ClimbExit/position = Vector2( 0, 0 )
states/Die/node = SubResource( 25 )
states/Die/position = Vector2( 0, 0 )
states/FindClimbTarget/node = SubResource( 27 )
states/FindClimbTarget/position = Vector2( 0, 0 )
states/IdleAim/node = SubResource( 39 )
states/IdleAim/position = Vector2( 0, 0 )
states/Jump/node = SubResource( 74 )
states/Jump/position = Vector2( 0, 0 )
states/Reload/node = SubResource( 76 )
states/Reload/position = Vector2( 0, 0 )
states/ShootOneHand/node = SubResource( 83 )
states/ShootOneHand/position = Vector2( 0, 0 )
states/Start/node = SubResource( 85 )
states/Start/position = Vector2( 612.453, 244.689 )
states/UseReact/node = SubResource( 86 )
states/UseReact/position = Vector2( 0, 0 )
transitions = [ "Start", "FindClimbTarget", SubResource( 87 ), "FindClimbTarget", "Jump", SubResource( 88 ), "Jump", "Start", SubResource( 90 ), "Jump", "Start", SubResource( 92 ), "Jump", "Start", SubResource( 93 ), "FindClimbTarget", "Climb", SubResource( 95 ), "Climb", "ClimbExit", SubResource( 97 ), "Climb", "ClimbExit", SubResource( 98 ), "ClimbExit", "Start", SubResource( 99 ), "Start", "IdleAim", SubResource( 101 ), "IdleAim", "Start", SubResource( 102 ), "Start", "UseReact", SubResource( 103 ), "UseReact", "ShootOneHand", SubResource( 105 ), "ShootOneHand", "IdleAim", SubResource( 107 ), "IdleAim", "UseReact", SubResource( 108 ), "UseReact", "Start", SubResource( 109 ), "ShootOneHand", "Start", SubResource( 110 ), "ShootOneHand", "UseReact", SubResource( 111 ), "Start", "Reload", SubResource( 112 ), "Reload", "Start", SubResource( 113 ), "Start", "Die", SubResource( 114 ), "Die", "Start", SubResource( 115 ), "Start", "FindClimbTarget", SubResource( 87 ), "FindClimbTarget", "Jump", SubResource( 88 ), "Jump", "Start", SubResource( 90 ), "Jump", "Start", SubResource( 92 ), "Jump", "Start", SubResource( 93 ), "FindClimbTarget", "Climb", SubResource( 95 ), "Climb", "ClimbExit", SubResource( 97 ), "Climb", "ClimbExit", SubResource( 98 ), "ClimbExit", "Start", SubResource( 99 ), "Start", "IdleAim", SubResource( 101 ), "IdleAim", "Start", SubResource( 102 ), "Start", "UseReact", SubResource( 103 ), "UseReact", "ShootOneHand", SubResource( 105 ), "ShootOneHand", "IdleAim", SubResource( 107 ), "IdleAim", "UseReact", SubResource( 108 ), "UseReact", "Start", SubResource( 109 ), "ShootOneHand", "Start", SubResource( 110 ), "ShootOneHand", "UseReact", SubResource( 111 ), "Start", "Reload", SubResource( 112 ), "Reload", "Start", SubResource( 113 ), "Start", "Die", SubResource( 114 ), "Die", "Start", SubResource( 115 ) ]
start_node = "Start"
graph_offset = Vector2( 10.4534, 38.6886 )
script = SubResource( 1 )
__meta__ = {

}
statemachine = ""
chain = false

[sub_resource type="AnimationNodeStateMachinePlayback" id=117]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachinePlayback" id=118]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachinePlayback" id=119]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachinePlayback" id=120]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachinePlayback" id=121]
__meta__ = {

}

[sub_resource type="AnimationNodeStateMachinePlayback" id=122]
__meta__ = {

}

[node name="Behavior" type="AnimationTree"]
tree_root = SubResource( 116 )
anim_player = NodePath("AnimationPlayer")
active = true
parameters/playback = SubResource( 117 )
parameters/Climb/playback = SubResource( 118 )
parameters/IdleAim/playback = SubResource( 119 )
parameters/IdleAim/ShootOneHand/Blend3/blend_amount = 0.0
parameters/Jump/blend_position = Vector2( 0, 0 )
parameters/Jump/3/playback = SubResource( 120 )
parameters/Jump/4/playback = SubResource( 121 )
parameters/Jump/5/playback = SubResource( 122 )
parameters/ShootOneHand/Blend3/blend_amount = 0.0
script = ExtResource( 1 )
__meta__ = {

}
schema_type = "Action"

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
root_node = NodePath("../../AnimLayerMovement/neo_reference_skeleton")
anims/Death_Backward = ExtResource( 2 )
anims/Death_Forward = ExtResource( 3 )
anims/Death_Headshot = ExtResource( 4 )
anims/Death_Minimum = ExtResource( 5 )
anims/Death_Stomach = ExtResource( 6 )
anims/DefaultAnim = ExtResource( 7 )
anims/ReloadBeretta = ExtResource( 8 )
anims/ShootBeretta = ExtResource( 9 )
anims/ShootBerettaIdle = ExtResource( 10 )
anims/ShootBerettaIdle_Down = ExtResource( 11 )
anims/ShootBerettaIdle_Up = ExtResource( 12 )
anims/ShootBeretta_Down = ExtResource( 13 )
anims/ShootBeretta_Up = ExtResource( 14 )
anims/death_knees = ExtResource( 15 )
__meta__ = {

}
